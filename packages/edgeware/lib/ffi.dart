// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Edgeware Client Binding
class RawEdgeware {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  RawEdgeware(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// Free (Drop) `AccountInfo` allocated by Rust.
  ///
  /// ### Safety
  /// this assumes that the given pointer is not null.
  void edg_account_info_free(
    ffi.Pointer<AccountInfo> ptr,
  ) {
    _edg_account_info_free ??= _dylib.lookupFunction<_c_edg_account_info_free,
        _dart_edg_account_info_free>('edg_account_info_free');
    return _edg_account_info_free(
      ptr,
    );
  }

  _dart_edg_account_info_free _edg_account_info_free;

  /// Check for a string is in ss58 format.
  ///
  /// ### Safety
  /// this assumes that `address` is not null and it is a valid utf8 string`.
  int edg_check_ss58_format(
    ffi.Pointer<ffi.Int8> address,
  ) {
    _edg_check_ss58_format ??= _dylib.lookupFunction<_c_edg_check_ss58_format,
        _dart_edg_check_ss58_format>('edg_check_ss58_format');
    return _edg_check_ss58_format(
      address,
    );
  }

  _dart_edg_check_ss58_format _edg_check_ss58_format;

  /// Backup KeyPair and get a Mnemonic phrase.
  ///
  /// ### Note
  /// you should call `edg_string_free` to free this string after you done with
  /// it.
  ///
  /// ### Safety
  /// this assumes that `keypair` is not null and it is a valid `KeyPair`.
  ffi.Pointer<ffi.Int8> edg_keypair_backup(
    ffi.Pointer<ffi.Void> keypair,
  ) {
    _edg_keypair_backup ??=
        _dylib.lookupFunction<_c_edg_keypair_backup, _dart_edg_keypair_backup>(
            'edg_keypair_backup');
    return _edg_keypair_backup(
      keypair,
    );
  }

  _dart_edg_keypair_backup _edg_keypair_backup;

  /// Get `KeyPair`'s Entropy and return 1 (true).
  /// the `out` array length must be equal to the `KeyPair`s entropy length.
  ///
  /// + 16 bytes for 12 words.
  /// + 20 bytes for 15 words.
  /// + 24 bytes for 18 words.
  /// + 28 bytes for 21 words.
  /// + 32 bytes for 24 words.
  ///
  /// Any other length will return an error 0 (false).
  /// ### Safety
  /// this assumes that `keypair` is not null and it is a valid `KeyPair`.
  int edg_keypair_entropy(
    ffi.Pointer<ffi.Void> keypair,
    ffi.Pointer<FfiArray> out,
  ) {
    _edg_keypair_entropy ??= _dylib.lookupFunction<_c_edg_keypair_entropy,
        _dart_edg_keypair_entropy>('edg_keypair_entropy');
    return _edg_keypair_entropy(
      keypair,
      out,
    );
  }

  _dart_edg_keypair_entropy _edg_keypair_entropy;

  /// Free(Clean, Drop) the KeyPair.
  ///
  /// ### Safety
  /// this assumes that `ptr` is not null ptr
  void edg_keypair_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    _edg_keypair_free ??=
        _dylib.lookupFunction<_c_edg_keypair_free, _dart_edg_keypair_free>(
            'edg_keypair_free');
    return _edg_keypair_free(
      ptr,
    );
  }

  _dart_edg_keypair_free _edg_keypair_free;

  /// Init KeyPair using the entropy.
  ///
  /// ### Safety
  /// this assumes that `entropy` is not null and is 16 byte length array.
  /// this assumes that `password` is not null and it is a valid utf8 string.
  ffi.Pointer<ffi.Void> edg_keypair_init(
    ffi.Pointer<FfiArray> entropy,
    ffi.Pointer<ffi.Int8> password,
  ) {
    _edg_keypair_init ??=
        _dylib.lookupFunction<_c_edg_keypair_init, _dart_edg_keypair_init>(
            'edg_keypair_init');
    return _edg_keypair_init(
      entropy,
      password,
    );
  }

  _dart_edg_keypair_init _edg_keypair_init;

  /// Create new KeyPair.
  /// this will generate a new KeyPair locally.
  ///
  /// ### Safety
  /// this assumes that `password` is not null and it is a valid utf8 string.
  ffi.Pointer<ffi.Void> edg_keypair_new(
    ffi.Pointer<ffi.Int8> password,
  ) {
    _edg_keypair_new ??=
        _dylib.lookupFunction<_c_edg_keypair_new, _dart_edg_keypair_new>(
            'edg_keypair_new');
    return _edg_keypair_new(
      password,
    );
  }

  _dart_edg_keypair_new _edg_keypair_new;

  /// Get `KeyPair`'s Public Key in ss58 format.
  ///
  /// ### Note
  /// you should call `edg_string_free` to free this string after you done with
  /// it.
  ///
  /// ### Safety
  /// this assumes that `keypair` is not null and it is a valid `KeyPair`.
  ffi.Pointer<ffi.Int8> edg_keypair_public(
    ffi.Pointer<ffi.Void> keypair,
  ) {
    _edg_keypair_public ??=
        _dylib.lookupFunction<_c_edg_keypair_public, _dart_edg_keypair_public>(
            'edg_keypair_public');
    return _edg_keypair_public(
      keypair,
    );
  }

  _dart_edg_keypair_public _edg_keypair_public;

  /// Restore KeyPair using Mnemonic phrase.
  ///
  /// ### Safety
  /// this assumes that `phrase` is not null and is 16 byte length array.
  /// this assumes that `password` is not null and it is a valid utf8 string.
  ffi.Pointer<ffi.Void> edg_keypair_restore(
    ffi.Pointer<ffi.Int8> phrase,
    ffi.Pointer<ffi.Int8> password,
  ) {
    _edg_keypair_restore ??= _dylib.lookupFunction<_c_edg_keypair_restore,
        _dart_edg_keypair_restore>('edg_keypair_restore');
    return _edg_keypair_restore(
      phrase,
      password,
    );
  }

  _dart_edg_keypair_restore _edg_keypair_restore;

  /// A Hack around to force Xcode on iOS to link our static lib
  /// this a noop function, so it dose not make sense to call it yourself.
  void edg_link_me_please() {
    _edg_link_me_please ??=
        _dylib.lookupFunction<_c_edg_link_me_please, _dart_edg_link_me_please>(
            'edg_link_me_please');
    return _edg_link_me_please();
  }

  _dart_edg_link_me_please _edg_link_me_please;

  /// Transfer `amount` from the provided `KeyPair` to the provided address.
  ///
  /// The Pointer is just a number that can be derefrenced to get the data.
  /// ### Safety
  /// this assumes that `to_ss58` is not null and it is a valid utf8 `string`.
  /// this assumes that `client` is not null and it is a valid RpcClient.
  /// this assumes that `keypair` is not null and it is a valid KeyPair.
  int edg_rpc_client_balance_transfer(
    int port,
    ffi.Pointer<ffi.Void> client,
    ffi.Pointer<ffi.Void> keypair,
    ffi.Pointer<ffi.Int8> to_ss58,
    ffi.Pointer<ffi.Int8> amount,
  ) {
    _edg_rpc_client_balance_transfer ??= _dylib.lookupFunction<
            _c_edg_rpc_client_balance_transfer,
            _dart_edg_rpc_client_balance_transfer>(
        'edg_rpc_client_balance_transfer');
    return _edg_rpc_client_balance_transfer(
      port,
      client,
      keypair,
      to_ss58,
      amount,
    );
  }

  _dart_edg_rpc_client_balance_transfer _edg_rpc_client_balance_transfer;

  /// Free(Clean, Drop) the RpcClient.
  ///
  /// ### Safety
  /// this assumes that `ptr` is not null ptr
  void edg_rpc_client_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    _edg_rpc_client_free ??= _dylib.lookupFunction<_c_edg_rpc_client_free,
        _dart_edg_rpc_client_free>('edg_rpc_client_free');
    return _edg_rpc_client_free(
      ptr,
    );
  }

  _dart_edg_rpc_client_free _edg_rpc_client_free;

  /// Create and Init the RPC Client return 1 (true).
  /// the RPC Client pointer is reterned over the port.
  ///
  /// The Pointer is just a number that can be derefrenced to get the data.
  /// ### Safety
  /// this assumes that `url` is not null and it is a valid utf8 string`.
  int edg_rpc_client_init(
    int port,
    ffi.Pointer<ffi.Int8> url,
  ) {
    _edg_rpc_client_init ??= _dylib.lookupFunction<_c_edg_rpc_client_init,
        _dart_edg_rpc_client_init>('edg_rpc_client_init');
    return _edg_rpc_client_init(
      port,
      url,
    );
  }

  _dart_edg_rpc_client_init _edg_rpc_client_init;

  /// Query the chain for Account Info return 1 (true).
  /// the `AccountInfo` pointer is reterned over the port.
  ///
  /// The Pointer is just a number that can be derefrenced to get the data.
  /// ### Safety
  /// this assumes that `ss58` is not null and it is a valid utf8 `string`.
  int edg_rpc_client_query_account_info(
    int port,
    ffi.Pointer<ffi.Void> client,
    ffi.Pointer<ffi.Int8> ss58,
  ) {
    _edg_rpc_client_query_account_info ??= _dylib.lookupFunction<
            _c_edg_rpc_client_query_account_info,
            _dart_edg_rpc_client_query_account_info>(
        'edg_rpc_client_query_account_info');
    return _edg_rpc_client_query_account_info(
      port,
      client,
      ss58,
    );
  }

  _dart_edg_rpc_client_query_account_info _edg_rpc_client_query_account_info;

  /// Free (Drop) a string value allocated by Rust.
  ///
  /// ### Safety
  /// this assumes that the given pointer is not null.
  void edg_string_free(
    ffi.Pointer<ffi.Int8> ptr,
  ) {
    _edg_string_free ??=
        _dylib.lookupFunction<_c_edg_string_free, _dart_edg_string_free>(
            'edg_string_free');
    return _edg_string_free(
      ptr,
    );
  }

  _dart_edg_string_free _edg_string_free;
}

class AccountInfo extends ffi.Struct {
  /// Non-reserved part of the balance. There may still be restrictions on
  /// this, but it is the total pool what may in principle be
  /// transferred, reserved and used for tipping.
  ///
  /// This is the only balance that matters in terms of most operations on
  /// tokens. It alone is used to determine the balance when in the
  /// contract execution environment.
  ffi.Pointer<ffi.Int8> free;

  /// Balance which is reserved and may not be used at all.
  ///
  /// This can still get slashed, but gets slashed last of all.
  ///
  /// This balance is a 'reserve' balance that other subsystems use in order
  /// to set aside tokens that are still 'owned' by the account holder,
  /// but which are suspendable.
  ffi.Pointer<ffi.Int8> reserved;

  /// The amount that `free` may not drop below when withdrawing for
  /// *anything except transaction fee payment*.
  ffi.Pointer<ffi.Int8> misc_frozen;

  /// The amount that `free` may not drop below when withdrawing specifically
  /// for transaction fee payment.
  ffi.Pointer<ffi.Int8> fee_frozen;
}

/// A Fixed Sized FFI compatable Array (Buffer View)
class FfiArray extends ffi.Struct {
  ffi.Pointer<ffi.Uint8> buf;

  @ffi.Uint64()
  int len;
}

typedef _c_edg_account_info_free = ffi.Void Function(
  ffi.Pointer<AccountInfo> ptr,
);

typedef _dart_edg_account_info_free = void Function(
  ffi.Pointer<AccountInfo> ptr,
);

typedef _c_edg_check_ss58_format = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> address,
);

typedef _dart_edg_check_ss58_format = int Function(
  ffi.Pointer<ffi.Int8> address,
);

typedef _c_edg_keypair_backup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _dart_edg_keypair_backup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _c_edg_keypair_entropy = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> keypair,
  ffi.Pointer<FfiArray> out,
);

typedef _dart_edg_keypair_entropy = int Function(
  ffi.Pointer<ffi.Void> keypair,
  ffi.Pointer<FfiArray> out,
);

typedef _c_edg_keypair_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_edg_keypair_free = void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_edg_keypair_init = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FfiArray> entropy,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_edg_keypair_init = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FfiArray> entropy,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_edg_keypair_new = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_edg_keypair_new = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_edg_keypair_public = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _dart_edg_keypair_public = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _c_edg_keypair_restore = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> phrase,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_edg_keypair_restore = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> phrase,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_edg_link_me_please = ffi.Void Function();

typedef _dart_edg_link_me_please = void Function();

typedef _c_edg_rpc_client_balance_transfer = ffi.Int32 Function(
  ffi.Int64 port,
  ffi.Pointer<ffi.Void> client,
  ffi.Pointer<ffi.Void> keypair,
  ffi.Pointer<ffi.Int8> to_ss58,
  ffi.Pointer<ffi.Int8> amount,
);

typedef _dart_edg_rpc_client_balance_transfer = int Function(
  int port,
  ffi.Pointer<ffi.Void> client,
  ffi.Pointer<ffi.Void> keypair,
  ffi.Pointer<ffi.Int8> to_ss58,
  ffi.Pointer<ffi.Int8> amount,
);

typedef _c_edg_rpc_client_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_edg_rpc_client_free = void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_edg_rpc_client_init = ffi.Int32 Function(
  ffi.Int64 port,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_edg_rpc_client_init = int Function(
  int port,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_edg_rpc_client_query_account_info = ffi.Int32 Function(
  ffi.Int64 port,
  ffi.Pointer<ffi.Void> client,
  ffi.Pointer<ffi.Int8> ss58,
);

typedef _dart_edg_rpc_client_query_account_info = int Function(
  int port,
  ffi.Pointer<ffi.Void> client,
  ffi.Pointer<ffi.Int8> ss58,
);

typedef _c_edg_string_free = ffi.Void Function(
  ffi.Pointer<ffi.Int8> ptr,
);

typedef _dart_edg_string_free = void Function(
  ffi.Pointer<ffi.Int8> ptr,
);
