// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Edgeware Client Binding
class RawEdgeware {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  RawEdgeware(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// Backup KeyPair and get a Mnemonic phrase.
  ///
  /// ### Note
  /// you should call `edg_string_free` to free this string after you done with it.
  ///
  /// ### Safety
  /// this assumes that `keypair` is not null and it is a valid `KeyPair`.
  ffi.Pointer<ffi.Int8> edg_keypair_backup(
    ffi.Pointer<ffi.Void> keypair,
  ) {
    _edg_keypair_backup ??=
        _dylib.lookupFunction<_c_edg_keypair_backup, _dart_edg_keypair_backup>(
            'edg_keypair_backup');
    return _edg_keypair_backup(
      keypair,
    );
  }

  _dart_edg_keypair_backup _edg_keypair_backup;

  /// Get `KeyPair`'s Entropy and return 1 (true).
  /// the `out` array length must be equal to the `KeyPair`s entropy length.
  ///
  /// + 16 bytes for 12 words.
  /// + 20 bytes for 15 words.
  /// + 24 bytes for 18 words.
  /// + 28 bytes for 21 words.
  /// + 32 bytes for 24 words.
  ///
  /// Any other length will return an error 0 (false).
  /// ### Safety
  /// this assumes that `keypair` is not null and it is a valid `KeyPair`.
  int edg_keypair_entropy(
    ffi.Pointer<ffi.Void> keypair,
    ffi.Pointer<FfiArray> out,
  ) {
    _edg_keypair_entropy ??= _dylib.lookupFunction<_c_edg_keypair_entropy,
        _dart_edg_keypair_entropy>('edg_keypair_entropy');
    return _edg_keypair_entropy(
      keypair,
      out,
    );
  }

  _dart_edg_keypair_entropy _edg_keypair_entropy;

  /// Free(Clean, Drop) the KeyPair.
  ///
  /// ### Safety
  /// this assumes that `ptr` is not null ptr
  void edg_keypair_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    _edg_keypair_free ??=
        _dylib.lookupFunction<_c_edg_keypair_free, _dart_edg_keypair_free>(
            'edg_keypair_free');
    return _edg_keypair_free(
      ptr,
    );
  }

  _dart_edg_keypair_free _edg_keypair_free;

  /// Init KeyPair using the entropy.
  ///
  /// ### Safety
  /// this assumes that `entropy` is not null and is 16 byte length array.
  /// this assumes that `password` is not null and it is a valid utf8 string.
  ffi.Pointer<ffi.Void> edg_keypair_init(
    ffi.Pointer<FfiArray> entropy,
    ffi.Pointer<ffi.Int8> password,
  ) {
    _edg_keypair_init ??=
        _dylib.lookupFunction<_c_edg_keypair_init, _dart_edg_keypair_init>(
            'edg_keypair_init');
    return _edg_keypair_init(
      entropy,
      password,
    );
  }

  _dart_edg_keypair_init _edg_keypair_init;

  /// Create new KeyPair.
  /// this will generate a new KeyPair locally.
  ///
  /// ### Safety
  /// this assumes that `password` is not null and it is a valid utf8 string.
  ffi.Pointer<ffi.Void> edg_keypair_new(
    ffi.Pointer<ffi.Int8> password,
  ) {
    _edg_keypair_new ??=
        _dylib.lookupFunction<_c_edg_keypair_new, _dart_edg_keypair_new>(
            'edg_keypair_new');
    return _edg_keypair_new(
      password,
    );
  }

  _dart_edg_keypair_new _edg_keypair_new;

  /// Get `KeyPair`'s Public Key in ss58 format.
  ///
  /// ### Note
  /// you should call `edg_string_free` to free this string after you done with it.
  ///
  /// ### Safety
  /// this assumes that `keypair` is not null and it is a valid `KeyPair`.
  ffi.Pointer<ffi.Int8> edg_keypair_public(
    ffi.Pointer<ffi.Void> keypair,
  ) {
    _edg_keypair_public ??=
        _dylib.lookupFunction<_c_edg_keypair_public, _dart_edg_keypair_public>(
            'edg_keypair_public');
    return _edg_keypair_public(
      keypair,
    );
  }

  _dart_edg_keypair_public _edg_keypair_public;

  /// Restore KeyPair using Mnemonic phrase.
  ///
  /// ### Safety
  /// this assumes that `phrase` is not null and is 16 byte length array.
  /// this assumes that `password` is not null and it is a valid utf8 string.
  ffi.Pointer<ffi.Void> edg_keypair_restore(
    ffi.Pointer<ffi.Int8> phrase,
    ffi.Pointer<ffi.Int8> password,
  ) {
    _edg_keypair_restore ??= _dylib.lookupFunction<_c_edg_keypair_restore,
        _dart_edg_keypair_restore>('edg_keypair_restore');
    return _edg_keypair_restore(
      phrase,
      password,
    );
  }

  _dart_edg_keypair_restore _edg_keypair_restore;

  /// A Hack around to force Xcode on iOS to link our static lib
  /// this a noop function, so it dose not make sense to call it yourself.
  void edg_link_me_please() {
    _edg_link_me_please ??=
        _dylib.lookupFunction<_c_edg_link_me_please, _dart_edg_link_me_please>(
            'edg_link_me_please');
    return _edg_link_me_please();
  }

  _dart_edg_link_me_please _edg_link_me_please;

  /// Free (Drop) a string value allocated by Rust.
  ///
  /// ### Safety
  /// this assumes that the given pointer is not null.
  void edg_string_free(
    ffi.Pointer<ffi.Int8> ptr,
  ) {
    _edg_string_free ??=
        _dylib.lookupFunction<_c_edg_string_free, _dart_edg_string_free>(
            'edg_string_free');
    return _edg_string_free(
      ptr,
    );
  }

  _dart_edg_string_free _edg_string_free;
}

/// A Fixed Sized FFI compatable Array (Buffer View)
class FfiArray extends ffi.Struct {
  ffi.Pointer<ffi.Uint8> buf;

  @ffi.Uint64()
  int len;
}

typedef _c_edg_keypair_backup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _dart_edg_keypair_backup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _c_edg_keypair_entropy = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> keypair,
  ffi.Pointer<FfiArray> out,
);

typedef _dart_edg_keypair_entropy = int Function(
  ffi.Pointer<ffi.Void> keypair,
  ffi.Pointer<FfiArray> out,
);

typedef _c_edg_keypair_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_edg_keypair_free = void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_edg_keypair_init = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FfiArray> entropy,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_edg_keypair_init = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FfiArray> entropy,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_edg_keypair_new = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_edg_keypair_new = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_edg_keypair_public = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _dart_edg_keypair_public = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> keypair,
);

typedef _c_edg_keypair_restore = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> phrase,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_edg_keypair_restore = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> phrase,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_edg_link_me_please = ffi.Void Function();

typedef _dart_edg_link_me_please = void Function();

typedef _c_edg_string_free = ffi.Void Function(
  ffi.Pointer<ffi.Int8> ptr,
);

typedef _dart_edg_string_free = void Function(
  ffi.Pointer<ffi.Int8> ptr,
);
